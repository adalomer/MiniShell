42 okullarÄ±ndaki minishell projesi, kendi kÃ¼Ã§Ã¼k bir kabuk (shell) programÄ±nÄ± yazmanÄ± hedefleyen bir projedir. Bu projede birÃ§ok alt konu birleÅŸir: parsing, execution, pipes, redirections, environment management, builtins, ve signal handling gibi.

AÅŸaÄŸÄ±da, projeyi ana baÅŸlÄ±klarÄ±na ayÄ±rarak hangi kod bloklarÄ±nÄ±n olmasÄ± gerektiÄŸini, bu bloklarÄ±n amaÃ§larÄ±nÄ± ve dikkat edilmesi gereken Ã¶nemli noktalarÄ± aÃ§Ä±klÄ±yorum:

ğŸ”¹ 1. Input & Lexing (Tokenizer)
ğŸ“Œ AmaÃ§:
KullanÄ±cÄ±nÄ±n girdiÄŸi komutu satÄ±r satÄ±r okuyup, token adÄ± verilen anlamlÄ± parÃ§alara ayÄ±rmak.

ğŸ“¦ Gerekli Kod BloklarÄ±:
readline() ile input alma

Historyâ€™yi yÃ¶netme (add_history())

Stringâ€™i tokenâ€™lara ayÄ±rma (space, pipe |, redirection <, >, <<, >>, quotes ', " gibi)

Quotes iÃ§indeki boÅŸluklarÄ± ayÄ±rmama

Escape karakteri yÃ¶netimi

âš ï¸ Dikkat Edilecekler:
" ve ' quoteâ€™larÄ±nÄ±n kapalÄ± olduÄŸundan emin olun.

Tokenâ€™larÄ± ayÄ±rÄ±rken Ã¶rneÄŸin ls -l | grep txt > out.txt gibi karmaÅŸÄ±k yapÄ±larÄ± doÄŸru parÃ§aladÄ±ÄŸÄ±nÄ±zdan emin olun.

HatalÄ± syntax (Ã¶rneÄŸin | |, >'Ã¼n sonunda komut olmamasÄ±) kontrol edilmeli.

ğŸ”¹ 2. Parsing (Syntax Tree veya Command Structs)
ğŸ“Œ AmaÃ§:
Lexing sonucunda oluÅŸan token'larÄ± anlamlÄ± komut bloklarÄ±na dÃ¶nÃ¼ÅŸtÃ¼rmek.

ğŸ“¦ Gerekli Kod BloklarÄ±:
Tokenâ€™lardan Command structâ€™larÄ± Ã¼retme

Komut adÄ± (Ã¶rn. ls)

ArgÃ¼manlar (Ã¶rn. -l)

Redirection'lar (Ã¶rn. > file.txt)

Pipe ile baÄŸlanma durumu

heredoc varsa iÃ§eriÄŸini okuma ve geÃ§ici dosyada saklama

âš ï¸ Dikkat Edilecekler:
Her bir pipe, ayrÄ± bir command olarak ele alÄ±nmalÄ±.

heredoc sÄ±rasÄ±nda sinyal yakalama farklÄ± olur (Ã¶rneÄŸin Ctrl+C Ã§alÄ±ÅŸmalÄ± ama shell kapanmamalÄ±).

Redirectionâ€™lar bir komutla eÅŸleÅŸtirilirken sÄ±raya dikkat edilmeli.

ğŸ”¹ 3. Execution (Execve & Builtins)
ğŸ“Œ AmaÃ§:
Parse edilen komutlarÄ± Ã§alÄ±ÅŸtÄ±rmak. Gerekirse fork + execve ile, gerekirse shell iÃ§inde (builtins olarak).

ğŸ“¦ Gerekli Kod BloklarÄ±:
Builtin komutlarÄ± doÄŸrudan Ã§alÄ±ÅŸtÄ±r:

cd, echo, pwd, env, export, unset, exit

DÄ±ÅŸ komutlar iÃ§in:

fork(), execve() ve waitpid() kullan

PATH iÃ§inde komutlarÄ± arama

Her pipe iÃ§in child iÅŸlemler oluÅŸtur

âš ï¸ Dikkat Edilecekler:
Builtinâ€™ler fork edilmeyebilir (Ã¶rn. cd, exit doÄŸrudan shellâ€™in durumunu deÄŸiÅŸtirir)

Her pipe iÃ§in stdin ve stdout yÃ¶nlendirmesi yapÄ±lmalÄ±

execve hata mesajlarÄ± bashâ€™e benzer ÅŸekilde olmalÄ± (Ã¶rn. command not found)

ğŸ”¹ 4. Redirection (>, >>, <, <<)
ğŸ“Œ AmaÃ§:
GiriÅŸ ve Ã§Ä±kÄ±ÅŸÄ± yÃ¶nlendirmek.

ğŸ“¦ Gerekli Kod BloklarÄ±:
open(), dup2(), close() ile dosya yÃ¶nlendirme

< â†’ input dosyasÄ±

> â†’ output dosyasÄ± (overwrite)

>> â†’ output dosyasÄ± (append)

<< â†’ heredoc (kullanÄ±cÄ±nÄ±n yazdÄ±ÄŸÄ± metin)

âš ï¸ Dikkat Edilecekler:
Heredocâ€™da CTRL+C doÄŸru yakalanmalÄ±.

Dosya yoksa aÃ§Ä±lmalÄ±, varsa overwrite edilmemesi gereken yerde edilmemeli.

ğŸ”¹ 5. Pipes (|)
ğŸ“Œ AmaÃ§:
Komutlar arasÄ±nda veri akÄ±ÅŸÄ± saÄŸlamak.

ğŸ“¦ Gerekli Kod BloklarÄ±:
pipe(), fork(), dup2() ile standart output bir sonraki komutun input'una baÄŸlanÄ±r.

Birden fazla pipe'Ä± desteklemek gerekir.

âš ï¸ Dikkat Edilecekler:
Her pipe iÃ§in ayrÄ± process aÃ§Ä±lmalÄ±.

Pipe sonrasÄ± close()â€™lar doÄŸru yapÄ±lmazsa leak olur.

Ä°lk komutun stdinâ€™i normaldir, son komutun stdoutâ€™u normaldir.

ğŸ”¹ 6. Environment Variables ($, export, unset)
ğŸ“Œ AmaÃ§:
Shell deÄŸiÅŸkenlerini yÃ¶netmek.

ğŸ“¦ Gerekli Kod BloklarÄ±:
export VAR=value â†’ env listesine ekle

unset VAR â†’ envâ€™den sil

echo $VAR â†’ doÄŸru deÄŸiÅŸkeni yazdÄ±r

Ortam deÄŸiÅŸkenlerini envp'den kendi linked listâ€™inize kopyalayÄ±n

âš ï¸ Dikkat Edilecekler:
env komutu tÃ¼m ortam deÄŸiÅŸkenlerini listelemeli

$?, Ã¶zel bir deÄŸiÅŸkendir: son komutun Ã§Ä±kÄ±ÅŸ durumu

Parametre geniÅŸletme ($USER) quotes iÃ§inde farklÄ± davranÄ±r

ğŸ”¹ 7. Signals (Ctrl+C, Ctrl+\ vs.)
ğŸ“Œ AmaÃ§:
Shell davranÄ±ÅŸlarÄ±nÄ± sinyallere gÃ¶re deÄŸiÅŸtirmek.

ğŸ“¦ Gerekli Kod BloklarÄ±:
signal(SIGINT, handler) ile Ctrl+C yakala

SIGQUIT (Ctrl+) varsayÄ±lan davranÄ±ÅŸÄ±na dÃ¶nmeli childâ€™da

Heredoc sÄ±rasÄ±nda sinyal farklÄ± Ã§alÄ±ÅŸmalÄ±

âš ï¸ Dikkat Edilecekler:
Ana shellâ€™de Ctrl+C satÄ±rÄ± temizlemeli ama shell kapanmamalÄ±

SIGINT ile child process Ã¶ldÃ¼rÃ¼lmeli ama parent devam etmeli

ğŸ”¹ 8. Exit Status & Error Handling
ğŸ“Œ AmaÃ§:
Shell'in her komuttan sonra doÄŸru exit status Ã¼retmesini saÄŸlamak.

ğŸ“¦ Gerekli Kod BloklarÄ±:
exit komutu â†’ doÄŸru status ile shellâ€™i kapatmalÄ±

Her komut Ã§alÄ±ÅŸtÄ±ktan sonra WEXITSTATUS ile durumu oku

HatalÄ± durumlarda uygun hata mesajÄ± ver

âš ï¸ Dikkat Edilecekler:
exit 256 â†’ exit 0 ile aynÄ± deÄŸil (mask uygulanÄ±r)

command not found â†’ status 127

permission denied â†’ status 126
42 okulundaki Minishell projesi, bir Unix kabuÄŸunun (bash, zsh vb.) temel iÅŸlevlerini yeniden yazmayÄ± hedefler. AmaÃ§, bir komut satÄ±rÄ± yorumlayÄ±cÄ±sÄ± (shell) yazarak process yÃ¶netimi, file descriptor, sinyal yÃ¶netimi, parsing, redirection ve environment gibi temel Unix konularÄ±nÄ± Ã¶ÄŸrenmektir.

AÅŸaÄŸÄ±da sana Minishell projesinde yapman gerekenleri, Ã¶ÄŸrenmen gereken fonksiyonlarÄ±, kÃ¼tÃ¼phaneleri ve projedeki ana yapÄ± taÅŸlarÄ±nÄ± adÄ±m adÄ±m anlatÄ±yorum:

ğŸ”§ 1. GEREKSÄ°NÄ°MLER
âœ… Zorunlu Ã–zellikler
Prompt gÃ¶sterimi (Ã¶rneÄŸin: minishell$ )

KomutlarÄ± Ã§alÄ±ÅŸtÄ±rma (Ã¶rn. ls, echo, cat)

Tekli ve Ã§oklu komutlar (ls -la | grep txt)

Redirection: >, >>, <, <<

Pipe (|)

Builtin komutlarÄ± (Ã¶rn. cd, echo, pwd, export, unset, env, exit)

Environment deÄŸiÅŸkenleri yÃ¶netimi ($PATH, $USER gibi)

Signal handling (ctrl + C, ctrl + D, ctrl + \)

Global deÄŸiÅŸken yok (Norm kurallarÄ±na uygun yazÄ±m)

Bellek sÄ±zÄ±ntÄ±sÄ± olmamalÄ± (Valgrind kullanÄ±mÄ± Ã¶nerilir)

ğŸ§± 2. PROJEDEKÄ° ANA YAPILAR VE BLOKLAR
AÅŸaÄŸÄ±daki yapÄ±lar genel bir Minishell mimarisi oluÅŸturur:

BileÅŸen	GÃ¶rev
main.c	Uygulama giriÅŸ noktasÄ±, readline ve dÃ¶ngÃ¼yÃ¼ baÅŸlatÄ±r
parser.c	KullanÄ±cÄ±dan alÄ±nan string'i tokenize eder ve anlamlÄ± hale getirir
executor.c	KomutlarÄ± Ã§alÄ±ÅŸtÄ±rÄ±r, forking, piping, redirection yÃ¶netimi
builtin.c	Builtin komutlarÄ± uygular (cd, export, vs.)
env.c	Ortam deÄŸiÅŸkenlerini iÅŸler (getenv, setenv, vs.)
signal.c	Sinyal yÃ¶netimi (SIGINT, SIGQUIT)
redir.c	RedirectionlarÄ± (>, <, >>, <<) iÅŸler
pipe.c	Pipe ile komutlarÄ± birbirine baÄŸlar (`ls
utils/	YardÄ±mcÄ± fonksiyonlar (strjoin, ft_split, free_tab, vs.)

ğŸ§  3. KAZANILACAK BECERÄ°LER VE KONU BAÅLIKLARI
ğŸ”¸ Shell TasarÄ±mÄ± ve Parslama
readline() â†’ kullanÄ±cÄ± girdisi almak iÃ§in

strtok, ft_split, lexer, parser â†’ girdi ayrÄ±ÅŸtÄ±rma

quotes, escape chars, $VAR gibi karmaÅŸÄ±klÄ±klarÄ± yÃ¶netmek

ğŸ”¸ Process ve Pipe YÃ¶netimi
fork(), execve(), waitpid() â†’ yeni process aÃ§ma ve yÃ¶netme

pipe() â†’ komutlar arasÄ±nda veri iletimi

ğŸ”¸ Dosya YÃ¶nlendirme (Redirection)
dup(), dup2(), open(), close() â†’ stdout, stdin yÃ¶nlendirme

>, >>, <, << gibi yÃ¶nlendirme tÃ¼rleri

heredoc: << limiter â†’ Ã¶zel durum, kullanÄ±cÄ±dan gelen satÄ±rlar

ğŸ”¸ Signal Management (Sinyal YÃ¶netimi)
signal(), sigaction() â†’ Ctrl+C, Ctrl+\ davranÄ±ÅŸÄ±

readline iÃ§inde Ã¶zel sinyal yÃ¶netimi

ğŸ”¸ Builtin Komutlar
Shell'de ayrÄ± olarak handle edilmesi gereken komutlar:

echo

cd

pwd

export

unset

env

exit

ğŸ”¸ Ortam DeÄŸiÅŸkenleri YÃ¶netimi
$HOME, $PATH, $USER gibi deÄŸiÅŸkenlerin okunmasÄ± ve deÄŸiÅŸtirilmesi

envp Ã¼zerinden environment yapÄ±sÄ±nÄ± yÃ¶netme

getenv(), setenv(), unsetenv() (veya elle yazÄ±m)

ğŸ”¸ Bellek YÃ¶netimi
Her dÃ¶ngÃ¼de doÄŸru malloc/free kullanÄ±mÄ±

Her yerde valgrind ile leak kontrolÃ¼

ğŸ”§ 4. Ã–ÄRENÄ°LMESÄ° GEREKEN FONKSÄ°YONLAR (EN Ã‡OK KULLANILANLAR)
ğŸ“Œ I/O, Process, Redirection
Fonksiyon	AÃ§Ä±klama
readline()	prompt yazdÄ±rÄ±p kullanÄ±cÄ± girdisini alÄ±r
fork()	yeni process oluÅŸturur
execve()	yeni program Ã§alÄ±ÅŸtÄ±rÄ±r
pipe()	pipe yaratÄ±r
dup2()	dosya tanÄ±tÄ±cÄ±sÄ±nÄ± kopyalar (redir)
open()	dosya aÃ§ar (redir. iÃ§in)
close()	fd kapatma
waitpid()	child bekleme
access()	dosya eriÅŸilebilir mi kontrol eder

ğŸ“Œ Signal
Fonksiyon	AÃ§Ä±klama
signal()	sinyal iÅŸleyici tanÄ±mlar
sigaction()	signal yerine kullanÄ±labilir, daha gÃ¼venlidir
kill()	processâ€™e sinyal gÃ¶nderir

ğŸ“Œ String ve Parsing
Fonksiyon	AÃ§Ä±klama
strtok, strchr, strdup, strjoin	string iÅŸlemleri
getenv()	ortam deÄŸiÅŸkeni alÄ±r

âš’ï¸ 5. DOSYA YAPISI Ã–NERÄ°SÄ°
shell
Kopyala
DÃ¼zenle
minishell/
â”œâ”€â”€ Makefile
â”œâ”€â”€ main.c
â”œâ”€â”€ minishell.h
â”œâ”€â”€ parser/
â”‚   â”œâ”€â”€ lexer.c
â”‚   â”œâ”€â”€ parser.c
â”‚   â””â”€â”€ quotes.c
â”œâ”€â”€ executor/
â”‚   â”œâ”€â”€ executor.c
â”‚   â”œâ”€â”€ pipe.c
â”‚   â”œâ”€â”€ redirection.c
â”œâ”€â”€ builtins/
â”‚   â”œâ”€â”€ cd.c
â”‚   â”œâ”€â”€ export.c
â”‚   â”œâ”€â”€ env.c
â”‚   â”œâ”€â”€ unset.c
â”‚   â”œâ”€â”€ exit.c
â”‚   â””â”€â”€ echo.c
â”œâ”€â”€ signals/
â”‚   â””â”€â”€ signals.c
â”œâ”€â”€ env/
â”‚   â””â”€â”€ env_utils.c
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ ft_split.c
â”‚   â”œâ”€â”€ free_utils.c
â”‚   â””â”€â”€ string_utils.c
ğŸ” 6. UYGULAMA DÃ–NGÃœSÃœ
c
Kopyala
DÃ¼zenle
while (1)
{
	print_prompt();
	line = readline("minishell$ ");
	add_history(line);
	tokens = tokenize(line);
	commands = parse(tokens);
	execute(commands, envp);
	free_everything();
}
ğŸ§ª 7. TEST VE HATA KONTROLÃœ
âœ… Test Etmen Gerekenler:
ls -la | grep minishell

cat < infile | grep test > outfile

echo hello > file && cat file

export VAR=test && echo $VAR

cd, cd .., cd ~/, cd $HOME

exit 42 sonrasÄ± $? deÄŸeri

heredoc: cat << EOF ...

ğŸ¯ 8. Ä°LERÄ° SEVÄ°YE (Bonus iÃ§in)
&& ve || gibi mantÄ±ksal operatÃ¶rleri tanÄ±mak

Komut gruplandÄ±rma: (ls && echo ok)

Wildcard: *.c

History dosyasÄ±na kayÄ±t

