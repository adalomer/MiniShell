Elbette! 42 okullarÄ±ndaki minishell projesi, kendi kÃ¼Ã§Ã¼k bir kabuk (shell) programÄ±nÄ± yazmanÄ± hedefleyen bir projedir. Bu projede birÃ§ok alt konu birleÅŸir: parsing, execution, pipes, redirections, environment management, builtins, ve signal handling gibi.

AÅŸaÄŸÄ±da, projeyi ana baÅŸlÄ±klarÄ±na ayÄ±rarak hangi kod bloklarÄ±nÄ±n olmasÄ± gerektiÄŸini, bu bloklarÄ±n amaÃ§larÄ±nÄ± ve dikkat edilmesi gereken Ã¶nemli noktalarÄ± aÃ§Ä±klÄ±yorum:

ğŸ”¹ 1. Input & Lexing (Tokenizer)
ğŸ“Œ AmaÃ§:
KullanÄ±cÄ±nÄ±n girdiÄŸi komutu satÄ±r satÄ±r okuyup, token adÄ± verilen anlamlÄ± parÃ§alara ayÄ±rmak.

ğŸ“¦ Gerekli Kod BloklarÄ±:
readline() ile input alma

Historyâ€™yi yÃ¶netme (add_history())

Stringâ€™i tokenâ€™lara ayÄ±rma (space, pipe |, redirection <, >, <<, >>, quotes ', " gibi)

Quotes iÃ§indeki boÅŸluklarÄ± ayÄ±rmama

Escape karakteri yÃ¶netimi

âš ï¸ Dikkat Edilecekler:
" ve ' quoteâ€™larÄ±nÄ±n kapalÄ± olduÄŸundan emin olun.

Tokenâ€™larÄ± ayÄ±rÄ±rken Ã¶rneÄŸin ls -l | grep txt > out.txt gibi karmaÅŸÄ±k yapÄ±larÄ± doÄŸru parÃ§aladÄ±ÄŸÄ±nÄ±zdan emin olun.

HatalÄ± syntax (Ã¶rneÄŸin | |, >'Ã¼n sonunda komut olmamasÄ±) kontrol edilmeli.

ğŸ”¹ 2. Parsing (Syntax Tree veya Command Structs)
ğŸ“Œ AmaÃ§:
Lexing sonucunda oluÅŸan token'larÄ± anlamlÄ± komut bloklarÄ±na dÃ¶nÃ¼ÅŸtÃ¼rmek.

ğŸ“¦ Gerekli Kod BloklarÄ±:
Tokenâ€™lardan Command structâ€™larÄ± Ã¼retme

Komut adÄ± (Ã¶rn. ls)

ArgÃ¼manlar (Ã¶rn. -l)

Redirection'lar (Ã¶rn. > file.txt)

Pipe ile baÄŸlanma durumu

heredoc varsa iÃ§eriÄŸini okuma ve geÃ§ici dosyada saklama

âš ï¸ Dikkat Edilecekler:
Her bir pipe, ayrÄ± bir command olarak ele alÄ±nmalÄ±.

heredoc sÄ±rasÄ±nda sinyal yakalama farklÄ± olur (Ã¶rneÄŸin Ctrl+C Ã§alÄ±ÅŸmalÄ± ama shell kapanmamalÄ±).

Redirectionâ€™lar bir komutla eÅŸleÅŸtirilirken sÄ±raya dikkat edilmeli.

ğŸ”¹ 3. Execution (Execve & Builtins)
ğŸ“Œ AmaÃ§:
Parse edilen komutlarÄ± Ã§alÄ±ÅŸtÄ±rmak. Gerekirse fork + execve ile, gerekirse shell iÃ§inde (builtins olarak).

ğŸ“¦ Gerekli Kod BloklarÄ±:
Builtin komutlarÄ± doÄŸrudan Ã§alÄ±ÅŸtÄ±r:

cd, echo, pwd, env, export, unset, exit

DÄ±ÅŸ komutlar iÃ§in:

fork(), execve() ve waitpid() kullan

PATH iÃ§inde komutlarÄ± arama

Her pipe iÃ§in child iÅŸlemler oluÅŸtur

âš ï¸ Dikkat Edilecekler:
Builtinâ€™ler fork edilmeyebilir (Ã¶rn. cd, exit doÄŸrudan shellâ€™in durumunu deÄŸiÅŸtirir)

Her pipe iÃ§in stdin ve stdout yÃ¶nlendirmesi yapÄ±lmalÄ±

execve hata mesajlarÄ± bashâ€™e benzer ÅŸekilde olmalÄ± (Ã¶rn. command not found)

ğŸ”¹ 4. Redirection (>, >>, <, <<)
ğŸ“Œ AmaÃ§:
GiriÅŸ ve Ã§Ä±kÄ±ÅŸÄ± yÃ¶nlendirmek.

ğŸ“¦ Gerekli Kod BloklarÄ±:
open(), dup2(), close() ile dosya yÃ¶nlendirme

< â†’ input dosyasÄ±

> â†’ output dosyasÄ± (overwrite)

>> â†’ output dosyasÄ± (append)

<< â†’ heredoc (kullanÄ±cÄ±nÄ±n yazdÄ±ÄŸÄ± metin)

âš ï¸ Dikkat Edilecekler:
Heredocâ€™da CTRL+C doÄŸru yakalanmalÄ±.

Dosya yoksa aÃ§Ä±lmalÄ±, varsa overwrite edilmemesi gereken yerde edilmemeli.

ğŸ”¹ 5. Pipes (|)
ğŸ“Œ AmaÃ§:
Komutlar arasÄ±nda veri akÄ±ÅŸÄ± saÄŸlamak.

ğŸ“¦ Gerekli Kod BloklarÄ±:
pipe(), fork(), dup2() ile standart output bir sonraki komutun input'una baÄŸlanÄ±r.

Birden fazla pipe'Ä± desteklemek gerekir.

âš ï¸ Dikkat Edilecekler:
Her pipe iÃ§in ayrÄ± process aÃ§Ä±lmalÄ±.

Pipe sonrasÄ± close()â€™lar doÄŸru yapÄ±lmazsa leak olur.

Ä°lk komutun stdinâ€™i normaldir, son komutun stdoutâ€™u normaldir.

ğŸ”¹ 6. Environment Variables ($, export, unset)
ğŸ“Œ AmaÃ§:
Shell deÄŸiÅŸkenlerini yÃ¶netmek.

ğŸ“¦ Gerekli Kod BloklarÄ±:
export VAR=value â†’ env listesine ekle

unset VAR â†’ envâ€™den sil

echo $VAR â†’ doÄŸru deÄŸiÅŸkeni yazdÄ±r

Ortam deÄŸiÅŸkenlerini envp'den kendi linked listâ€™inize kopyalayÄ±n

âš ï¸ Dikkat Edilecekler:
env komutu tÃ¼m ortam deÄŸiÅŸkenlerini listelemeli

$?, Ã¶zel bir deÄŸiÅŸkendir: son komutun Ã§Ä±kÄ±ÅŸ durumu

Parametre geniÅŸletme ($USER) quotes iÃ§inde farklÄ± davranÄ±r

ğŸ”¹ 7. Signals (Ctrl+C, Ctrl+\ vs.)
ğŸ“Œ AmaÃ§:
Shell davranÄ±ÅŸlarÄ±nÄ± sinyallere gÃ¶re deÄŸiÅŸtirmek.

ğŸ“¦ Gerekli Kod BloklarÄ±:
signal(SIGINT, handler) ile Ctrl+C yakala

SIGQUIT (Ctrl+) varsayÄ±lan davranÄ±ÅŸÄ±na dÃ¶nmeli childâ€™da

Heredoc sÄ±rasÄ±nda sinyal farklÄ± Ã§alÄ±ÅŸmalÄ±

âš ï¸ Dikkat Edilecekler:
Ana shellâ€™de Ctrl+C satÄ±rÄ± temizlemeli ama shell kapanmamalÄ±

SIGINT ile child process Ã¶ldÃ¼rÃ¼lmeli ama parent devam etmeli

ğŸ”¹ 8. Exit Status & Error Handling
ğŸ“Œ AmaÃ§:
Shell'in her komuttan sonra doÄŸru exit status Ã¼retmesini saÄŸlamak.

ğŸ“¦ Gerekli Kod BloklarÄ±:
exit komutu â†’ doÄŸru status ile shellâ€™i kapatmalÄ±

Her komut Ã§alÄ±ÅŸtÄ±ktan sonra WEXITSTATUS ile durumu oku

HatalÄ± durumlarda uygun hata mesajÄ± ver

âš ï¸ Dikkat Edilecekler:
exit 256 â†’ exit 0 ile aynÄ± deÄŸil (mask uygulanÄ±r)

command not found â†’ status 127

permission denied â†’ status 126

ğŸ”¹ Genel Tavsiyeler:
ğŸ” Her komut yapÄ±sÄ±nÄ± struct command gibi bir yapÄ±da tut.

ğŸ§ª valgrind kullanarak bellek sÄ±zÄ±ntÄ±larÄ±nÄ± kontrol et.

ğŸ“œ 25 satÄ±r ve 5 fonksiyon kuralÄ±na dikkat et (Norminette).

ğŸ”„ main loop sonsuz dÃ¶ngÃ¼ ÅŸeklinde olmalÄ±: while (1)

ğŸ—‚ï¸ Ã–rnek Dosya YapÄ±sÄ±:
rust
Kopyala
DÃ¼zenle
minishell/
â”‚
â”œâ”€â”€ main.c                  -> Main loop ve readline
â”œâ”€â”€ lexer/                  -> Tokenizer fonksiyonlarÄ±
â”œâ”€â”€ parser/                 -> Syntax tree veya komut struct oluÅŸturma
â”œâ”€â”€ executor/               -> KomutlarÄ± Ã§alÄ±ÅŸtÄ±rma (pipes, redirections)
â”œâ”€â”€ builtins/               -> echo, cd, export, exit vs.
â”œâ”€â”€ env/                    -> Ortam deÄŸiÅŸkenlerini yÃ¶netme
â”œâ”€â”€ signals/                -> Signal handler'lar
â”œâ”€â”€ utils/                  -> String, fd, error handling yardÄ±mcÄ± fonksiyonlar
