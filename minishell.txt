42 okullarındaki minishell projesi, kendi küçük bir kabuk (shell) programını yazmanı hedefleyen bir projedir. Bu projede birçok alt konu birleşir: parsing, execution, pipes, redirections, environment management, builtins, ve signal handling gibi.

Aşağıda, projeyi ana başlıklarına ayırarak hangi kod bloklarının olması gerektiğini, bu blokların amaçlarını ve dikkat edilmesi gereken önemli noktaları açıklıyorum:

🔹 1. Input & Lexing (Tokenizer)
📌 Amaç:
Kullanıcının girdiği komutu satır satır okuyup, token adı verilen anlamlı parçalara ayırmak.

📦 Gerekli Kod Blokları:
readline() ile input alma

History’yi yönetme (add_history())

String’i token’lara ayırma (space, pipe |, redirection <, >, <<, >>, quotes ', " gibi)

Quotes içindeki boşlukları ayırmama

Escape karakteri yönetimi

⚠️ Dikkat Edilecekler:
" ve ' quote’larının kapalı olduğundan emin olun.

Token’ları ayırırken örneğin ls -l | grep txt > out.txt gibi karmaşık yapıları doğru parçaladığınızdan emin olun.

Hatalı syntax (örneğin | |, >'ün sonunda komut olmaması) kontrol edilmeli.

🔹 2. Parsing (Syntax Tree veya Command Structs)
📌 Amaç:
Lexing sonucunda oluşan token'ları anlamlı komut bloklarına dönüştürmek.

📦 Gerekli Kod Blokları:
Token’lardan Command struct’ları üretme

Komut adı (örn. ls)

Argümanlar (örn. -l)

Redirection'lar (örn. > file.txt)

Pipe ile bağlanma durumu

heredoc varsa içeriğini okuma ve geçici dosyada saklama

⚠️ Dikkat Edilecekler:
Her bir pipe, ayrı bir command olarak ele alınmalı.

heredoc sırasında sinyal yakalama farklı olur (örneğin Ctrl+C çalışmalı ama shell kapanmamalı).

Redirection’lar bir komutla eşleştirilirken sıraya dikkat edilmeli.

🔹 3. Execution (Execve & Builtins)
📌 Amaç:
Parse edilen komutları çalıştırmak. Gerekirse fork + execve ile, gerekirse shell içinde (builtins olarak).

📦 Gerekli Kod Blokları:
Builtin komutları doğrudan çalıştır:

cd, echo, pwd, env, export, unset, exit

Dış komutlar için:

fork(), execve() ve waitpid() kullan

PATH içinde komutları arama

Her pipe için child işlemler oluştur

⚠️ Dikkat Edilecekler:
Builtin’ler fork edilmeyebilir (örn. cd, exit doğrudan shell’in durumunu değiştirir)

Her pipe için stdin ve stdout yönlendirmesi yapılmalı

execve hata mesajları bash’e benzer şekilde olmalı (örn. command not found)

🔹 4. Redirection (>, >>, <, <<)
📌 Amaç:
Giriş ve çıkışı yönlendirmek.

📦 Gerekli Kod Blokları:
open(), dup2(), close() ile dosya yönlendirme

< → input dosyası

> → output dosyası (overwrite)

>> → output dosyası (append)

<< → heredoc (kullanıcının yazdığı metin)

⚠️ Dikkat Edilecekler:
Heredoc’da CTRL+C doğru yakalanmalı.

Dosya yoksa açılmalı, varsa overwrite edilmemesi gereken yerde edilmemeli.

🔹 5. Pipes (|)
📌 Amaç:
Komutlar arasında veri akışı sağlamak.

📦 Gerekli Kod Blokları:
pipe(), fork(), dup2() ile standart output bir sonraki komutun input'una bağlanır.

Birden fazla pipe'ı desteklemek gerekir.

⚠️ Dikkat Edilecekler:
Her pipe için ayrı process açılmalı.

Pipe sonrası close()’lar doğru yapılmazsa leak olur.

İlk komutun stdin’i normaldir, son komutun stdout’u normaldir.

🔹 6. Environment Variables ($, export, unset)
📌 Amaç:
Shell değişkenlerini yönetmek.

📦 Gerekli Kod Blokları:
export VAR=value → env listesine ekle

unset VAR → env’den sil

echo $VAR → doğru değişkeni yazdır

Ortam değişkenlerini envp'den kendi linked list’inize kopyalayın

⚠️ Dikkat Edilecekler:
env komutu tüm ortam değişkenlerini listelemeli

$?, özel bir değişkendir: son komutun çıkış durumu

Parametre genişletme ($USER) quotes içinde farklı davranır

🔹 7. Signals (Ctrl+C, Ctrl+\ vs.)
📌 Amaç:
Shell davranışlarını sinyallere göre değiştirmek.

📦 Gerekli Kod Blokları:
signal(SIGINT, handler) ile Ctrl+C yakala

SIGQUIT (Ctrl+) varsayılan davranışına dönmeli child’da

Heredoc sırasında sinyal farklı çalışmalı

⚠️ Dikkat Edilecekler:
Ana shell’de Ctrl+C satırı temizlemeli ama shell kapanmamalı

SIGINT ile child process öldürülmeli ama parent devam etmeli

🔹 8. Exit Status & Error Handling
📌 Amaç:
Shell'in her komuttan sonra doğru exit status üretmesini sağlamak.

📦 Gerekli Kod Blokları:
exit komutu → doğru status ile shell’i kapatmalı

Her komut çalıştıktan sonra WEXITSTATUS ile durumu oku

Hatalı durumlarda uygun hata mesajı ver

⚠️ Dikkat Edilecekler:
exit 256 → exit 0 ile aynı değil (mask uygulanır)

command not found → status 127

permission denied → status 126
42 okulundaki Minishell projesi, bir Unix kabuğunun (bash, zsh vb.) temel işlevlerini yeniden yazmayı hedefler. Amaç, bir komut satırı yorumlayıcısı (shell) yazarak process yönetimi, file descriptor, sinyal yönetimi, parsing, redirection ve environment gibi temel Unix konularını öğrenmektir.

Aşağıda sana Minishell projesinde yapman gerekenleri, öğrenmen gereken fonksiyonları, kütüphaneleri ve projedeki ana yapı taşlarını adım adım anlatıyorum:

🔧 1. GEREKSİNİMLER
✅ Zorunlu Özellikler
Prompt gösterimi (örneğin: minishell$ )

Komutları çalıştırma (örn. ls, echo, cat)

Tekli ve çoklu komutlar (ls -la | grep txt)

Redirection: >, >>, <, <<

Pipe (|)

Builtin komutları (örn. cd, echo, pwd, export, unset, env, exit)

Environment değişkenleri yönetimi ($PATH, $USER gibi)

Signal handling (ctrl + C, ctrl + D, ctrl + \)

Global değişken yok (Norm kurallarına uygun yazım)

Bellek sızıntısı olmamalı (Valgrind kullanımı önerilir)

🧱 2. PROJEDEKİ ANA YAPILAR VE BLOKLAR
Aşağıdaki yapılar genel bir Minishell mimarisi oluşturur:

Bileşen	Görev
main.c	Uygulama giriş noktası, readline ve döngüyü başlatır
parser.c	Kullanıcıdan alınan string'i tokenize eder ve anlamlı hale getirir
executor.c	Komutları çalıştırır, forking, piping, redirection yönetimi
builtin.c	Builtin komutları uygular (cd, export, vs.)
env.c	Ortam değişkenlerini işler (getenv, setenv, vs.)
signal.c	Sinyal yönetimi (SIGINT, SIGQUIT)
redir.c	Redirectionları (>, <, >>, <<) işler
pipe.c	Pipe ile komutları birbirine bağlar (`ls
utils/	Yardımcı fonksiyonlar (strjoin, ft_split, free_tab, vs.)

🧠 3. KAZANILACAK BECERİLER VE KONU BAŞLIKLARI
🔸 Shell Tasarımı ve Parslama
readline() → kullanıcı girdisi almak için

strtok, ft_split, lexer, parser → girdi ayrıştırma

quotes, escape chars, $VAR gibi karmaşıklıkları yönetmek

🔸 Process ve Pipe Yönetimi
fork(), execve(), waitpid() → yeni process açma ve yönetme

pipe() → komutlar arasında veri iletimi

🔸 Dosya Yönlendirme (Redirection)
dup(), dup2(), open(), close() → stdout, stdin yönlendirme

>, >>, <, << gibi yönlendirme türleri

heredoc: << limiter → özel durum, kullanıcıdan gelen satırlar

🔸 Signal Management (Sinyal Yönetimi)
signal(), sigaction() → Ctrl+C, Ctrl+\ davranışı

readline içinde özel sinyal yönetimi

🔸 Builtin Komutlar
Shell'de ayrı olarak handle edilmesi gereken komutlar:

echo

cd

pwd

export

unset

env

exit

🔸 Ortam Değişkenleri Yönetimi
$HOME, $PATH, $USER gibi değişkenlerin okunması ve değiştirilmesi

envp üzerinden environment yapısını yönetme

getenv(), setenv(), unsetenv() (veya elle yazım)

🔸 Bellek Yönetimi
Her döngüde doğru malloc/free kullanımı

Her yerde valgrind ile leak kontrolü

🔧 4. ÖĞRENİLMESİ GEREKEN FONKSİYONLAR (EN ÇOK KULLANILANLAR)
📌 I/O, Process, Redirection
Fonksiyon	Açıklama
readline()	prompt yazdırıp kullanıcı girdisini alır
fork()	yeni process oluşturur
execve()	yeni program çalıştırır
pipe()	pipe yaratır
dup2()	dosya tanıtıcısını kopyalar (redir)
open()	dosya açar (redir. için)
close()	fd kapatma
waitpid()	child bekleme
access()	dosya erişilebilir mi kontrol eder

📌 Signal
Fonksiyon	Açıklama
signal()	sinyal işleyici tanımlar
sigaction()	signal yerine kullanılabilir, daha güvenlidir
kill()	process’e sinyal gönderir

📌 String ve Parsing
Fonksiyon	Açıklama
strtok, strchr, strdup, strjoin	string işlemleri
getenv()	ortam değişkeni alır

⚒️ 5. DOSYA YAPISI ÖNERİSİ
shell
Kopyala
Düzenle
minishell/
├── Makefile
├── main.c
├── minishell.h
├── parser/
│   ├── lexer.c
│   ├── parser.c
│   └── quotes.c
├── executor/
│   ├── executor.c
│   ├── pipe.c
│   ├── redirection.c
├── builtins/
│   ├── cd.c
│   ├── export.c
│   ├── env.c
│   ├── unset.c
│   ├── exit.c
│   └── echo.c
├── signals/
│   └── signals.c
├── env/
│   └── env_utils.c
├── utils/
│   ├── ft_split.c
│   ├── free_utils.c
│   └── string_utils.c
🔁 6. UYGULAMA DÖNGÜSÜ
c
Kopyala
Düzenle
while (1)
{
	print_prompt();
	line = readline("minishell$ ");
	add_history(line);
	tokens = tokenize(line);
	commands = parse(tokens);
	execute(commands, envp);
	free_everything();
}
🧪 7. TEST VE HATA KONTROLÜ
✅ Test Etmen Gerekenler:
ls -la | grep minishell

cat < infile | grep test > outfile

echo hello > file && cat file

export VAR=test && echo $VAR

cd, cd .., cd ~/, cd $HOME

exit 42 sonrası $? değeri

heredoc: cat << EOF ...

🎯 8. İLERİ SEVİYE (Bonus için)
&& ve || gibi mantıksal operatörleri tanımak

Komut gruplandırma: (ls && echo ok)

Wildcard: *.c

History dosyasına kayıt

